const Dex = artifacts.require("Dex")
const Link = artifacts.require("Link")
const ETH = artifacts.require("ETH")
const truffleAssert = require('truffle-assertions')
contract.skip("Dex", accounts => {
    it("should have enough ETH deposited for buy order", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        await dex.addToken(web3.utils.fromUtf8("ETH"), eth.address)
        await eth.approve(dex.address, 100000)
        await dex.deposit(100000, web3.utils.fromUtf8("ETH"))
        await truffleAssert.passes(
            dex.createLimitOrder(0,  web3.utils.fromUtf8("ETH"), 10, 2900)
        )
        await truffleAssert.reverts(
            dex.createLimitOrder(0,  web3.utils.fromUtf8("ETH"), 200, 2900)
        )
    })
    it("should have enough token for sell order", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        await dex.addToken(web3.utils.fromUtf8("Link"), link.address)
        await link.approve(dex.address, 500)
        await dex.deposit(400, web3.utils.fromUtf8("Link"))
        await truffleAssert.passes(
            dex.createLimitOrder(1,  web3.utils.fromUtf8("Link"), 100, 40)
        )
    })
    it("should be descendent for buy order", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        await dex.addToken(web3.utils.fromUtf8("ETH"), eth.address)
        await dex.addToken(web3.utils.fromUtf8("Link"), link.address)
        await eth.approve(dex.address, 10000)
        await dex.deposit(10000, web3.utils.fromUtf8("ETH"))
        await dex.createLimitOrder(0,web3.utils.fromUtf8("Link"),10,40)
        await dex.createLimitOrder(0,web3.utils.fromUtf8("Link"),10,30)
        await dex.createLimitOrder(0,web3.utils.fromUtf8("Link"),10,50)
        let orderBook = await dex.getOrderBook(web3.utils.fromUtf8("Link"),0)
        assert(orderBook.length > 1, "Orderbook is short")
        for (let i = 0; i < orderBook.length - 1; i++){
            assert(orderBook[i].price >= orderBook[i+1].price, 'Not in order')
        }
    })
    it("should be ascendent for sell order", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        await dex.addToken(web3.utils.fromUtf8("ETH"), eth.address)
        await dex.addToken(web3.utils.fromUtf8("Link"), link.address)
        await link.approve(dex.address, 500)
        await dex.deposit(200, web3.utils.fromUtf8("Link"))
        await dex.createLimitOrder(1,web3.utils.fromUtf8("Link"),10,30)
        await dex.createLimitOrder(1,web3.utils.fromUtf8("Link"),10,20)
        await dex.createLimitOrder(1,web3.utils.fromUtf8("Link"),10,40)
        let orderBook = await dex.getOrderBook(web3.utils.fromUtf8("Link"),1)
        assert(orderBook.length > 1, "Orderbook is short")
        for (let i = 0; i < orderBook.length - 1; i++){
            assert(orderBook[i].price <= orderBook[i+1].price, 'Not in order')
        }
    })

})

contract("Dex", accounts => {
    it("should have enough token for sell market order", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        await dex.addToken(web3.utils.fromUtf8("Link"), link.address)
        await link.approve(dex.address, 100000)
        await dex.deposit(100000, web3.utils.fromUtf8("Link"))
        await truffleAssert.passes(
            dex.createMarketOrder(1,  web3.utils.fromUtf8("Link"), 15000)
        )
        await truffleAssert.reverts(
            dex.createMarketOrder(1,  web3.utils.fromUtf8("Link"), 150000)
        )
    })
    it("should have enough ETH for buy market order", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        await dex.addToken(web3.utils.fromUtf8("ETH"), eth.address)
        await eth.approve(dex.address, 120000)
        await dex.depositETH({value: 100000})
        await link.transfer(accounts[1],100000)
        await link.approve(dex.address, 100000, {from: accounts[1]})
        await dex.deposit(20000, web3.utils.fromUtf8("Link"), {from: accounts[1]})
        await truffleAssert.passes(
            dex.createMarketOrder(0,  web3.utils.fromUtf8("Link"), 15000)
        )
        await dex.createLimitOrder(1,web3.utils.fromUtf8("Link"),10,30, {from: accounts[1]})
        await dex.createMarketOrder(0,  web3.utils.fromUtf8("Link"), 15000)
    })
    it("should create an order even for empty orderbook", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        let orderBookBUY = await dex.getOrderBook(web3.utils.fromUtf8("Link"),0)
        let orderBookSELL = await dex.getOrderBook(web3.utils.fromUtf8("Link"),1)
        assert(orderBookBUY == 0, "Orderbook not empty")
        assert(orderBookSELL == 0, "Orderbook not empty")
        await truffleAssert.passes(
            dex.createMarketOrder(0,  web3.utils.fromUtf8("Link"), 15000)
        )
        await truffleAssert.passes(
            dex.createMarketOrder(1,  web3.utils.fromUtf8("Link"), 15000)
        )
    })
    it("should decrease the ETH balance of the buyer and the token balance of the seller with fulfilled orders", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        await dex.addToken(web3.utils.fromUtf8("ETH"), eth.address)
        await dex.addToken(web3.utils.fromUtf8("Link"), link.address)
        await eth.approve(dex.address, 100000)
        await link.approve(dex.address,200000)
        await dex.depositETH({value: 100000})
        await link.transfer(accounts[1],100000)
        await link.approve(dex.address, 100000, {from: accounts[1]})
        await dex.deposit(50000, web3.utils.fromUtf8("Link"), {from: accounts[1]})
        let balanceETH0 = await dex.balances(accounts[0],web3.utils.fromUtf8("ETH"))
        let balanceLink0 = await dex.balances(accounts[0],web3.utils.fromUtf8("Link"))
        let balanceLink1 = await dex.balances(accounts[1],web3.utils.fromUtf8("Link"))
        let balanceETH1 = await dex.balances(accounts[1],web3.utils.fromUtf8("ETH"))
        await dex.createLimitOrder(1,  web3.utils.fromUtf8("Link"), 100, 50, {from: accounts[1]})
        await dex.createMarketOrder(0, web3.utils.fromUtf8("Link"), 100)
        assert(await dex.balances(accounts[0],web3.utils.fromUtf8("ETH")) == balanceETH0 - web3.utils.toBN('5000'), "Balance ETH not adjusted")
        assert(await dex.balances(accounts[1],web3.utils.fromUtf8("Link")) == balanceLink1 - web3.utils.toBN('100'), "Balance Link not adjusted")
        assert(await dex.balances(accounts[0],web3.utils.fromUtf8("Link")) == balanceLink0 - web3.utils.toBN('-100'), "Balance Link not adjusted")
        assert(await dex.balances(accounts[1],web3.utils.fromUtf8("ETH")) == balanceETH1 - web3.utils.toBN('-5000'), "Balance ETH not adjusted")
    })
    it("should fill an order until the other side orderbook is empty or the order is filled", async() => {
        let dex = await Dex.deployed()
        let link = await Link.deployed()
        let eth = await ETH.deployed()
        await dex.addToken(web3.utils.fromUtf8("ETH"), eth.address)
        await dex.addToken(web3.utils.fromUtf8("Link"), link.address)
        await eth.approve(dex.address, 100000)
        await dex.deposit(100000, web3.utils.fromUtf8("ETH"))
        await link.approve(dex.address, 100000)
        await dex.deposit(100000, web3.utils.fromUtf8("Link"))
        await dex.createLimitOrder(1,  web3.utils.fromUtf8("Link"), 100, 40, {from: accounts[1]})
        await dex.createLimitOrder(1,  web3.utils.fromUtf8("Link"), 100, 40, {from: accounts[1]})
        await dex.createLimitOrder(1,  web3.utils.fromUtf8("Link"), 100, 40, {from: accounts[1]})
        await dex.createMarketOrder(0, web3.utils.fromUtf8("Link"), 300)
        let orderBookBUY = await dex.getOrderBook(web3.utils.fromUtf8("Link"),0)
        let orderBookSELL = await dex.getOrderBook(web3.utils.fromUtf8("Link"),1)
        assert(orderBookSELL.length == 0, "Orderbook not empty")
        assert(orderBookBUY.length == 0, "Orderbook not empty")
        await dex.createLimitOrder(1,  web3.utils.fromUtf8("Link"), 100, 40, {from: accounts[1]})
        await dex.createLimitOrder(1,  web3.utils.fromUtf8("Link"), 100, 40, {from: accounts[1]})
        await dex.createLimitOrder(1,  web3.utils.fromUtf8("Link"), 100, 40, {from: accounts[1]})
        await dex.createMarketOrder(0, web3.utils.fromUtf8("Link"), 400)
        orderBookBUY = await dex.getOrderBook(web3.utils.fromUtf8("Link"),0)
        orderBookSELL = await dex.getOrderBook(web3.utils.fromUtf8("Link"),1)
        assert(orderBookSELL.length == 0, "Orderbook not empty")
    })
})